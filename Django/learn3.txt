At the very beginning of your project, when you run python manage.py migrate, the migrate command looks at the INSTALLED_APPS settings and creates any necessary tables according to the
database settings in your mysite/settings.py

Some Field classes have required arguments such as the charField() which has a required argument of max_length. That is used not only in the database schema but in validation as well.
A Field can also have various optional arguments such as default. Finally, a relationship is defined using ForeignKey.

Django apps are pluggable. You can use an app in multiple projects, because they dont have to be tied to a given Django installation. Just like how we added the routes of the polls app
to the projects routes via the include() method from django.urls. We also need to include the polls app in the INSTALLED_APPS setting in settings.py

The sqlmigrate command takes migration names and returns their sql.

- Table names are automatically generated by combining the name of the app and the name of the model (this can be overriden)
- Primary Keys (IDs) are added automatically (this can be overriden)
- By convention, Django appends _id to the foreign key field name

python manage.py check - this checks for any problems in your project without making migrations or touching the database

The migrate command takes all the migrations that have not been applied (Django tracks which ones are applied using a special table in your database called django_migrations)

python manage.py shell gives you access to the interactive Django shell

Django also provides several useful filters such as __startswith, for datetime fields, we can also perform filtering like __year.

The way I see it is that with Django, if you want to get say, multiple results, then you use the filter() method. Question.objects.filter() but if you are looking to obtain a single
result, then you make use of the get() method. Also, if say, you want to find a model by its primary key. Just like how with Laravel, you would use the static find() method, with Django,
you can make use of the pk=xyz keyword argument on the get() method.

Also, just like how we have accessors with which we can append data onto schema in Laravel or virtuals to append stuff in Mongodb with node, we can also define methods on our models
through which we can do some form of computation and return stuff.

Basically in Django, anytime you create a foreign key linking, say between an Author and Books. In this case, there would be an author_id field on the Book model. In order to create
books via the Author model (We can easily create with Book()) meaning via the relationship. Django is going to create a set to house the child objects of the relationship. In this case,
the set is going to be the book_set. So just like how with Laravel, we can do $author->books()->create([]). With Django, we can do author.book_set.create().

Just like how we can execute queries on a model with for example, Author.objects.all(), Author.objects.filter() and Author.objects.get(), we can execute queries on the relationship just
like how we would do in Laravel. In Laravel, we would do something like $author->books()->firstWhere('name', 'Olamileke'). In Django, we can do something similar with
author.book_set.get(name='Olamileke')

python manage.py makemigrations
python manage.py migrate

