We can containerize virtually every single thing

CMD defines the command that will be run inside the container when the container starts

By default. Docker does not attach a terminal to a container when the container starts.

The ENTRYPOINT command works similarly to the CMD command, except that we can specify the operation that we want to be executed with the ENTRYPOINT command, and we can pass in arguments
when running the image and have it appeneded to ENTRYPOINT

Know how we make use of the ENTRYPOINT command to specify arguments to the start of the operation, if no argument is passed in, we can add a CMD after the ENTRYPOINT which will be made
use of as a default parameter in a sense

If you want to override the entrypoint command, you can do so by adding the --entrypoint command when running the docker image

When you install docker, it creates three networks automatically, bridge, none and host

bridge is the default network that a container gets attached to. If you would like to specify a different network for a container to be attached to, specify the --network parameter

The bridge is a private, internal network created by docker on the host that all containers get attached to, and they get an internal ip address.
Bridge is the one where we can map the internal ports in the container to the ports on the docker host. We can also remove any isolation between the docker host and the containers by 
making the containers run directly on the docker host's network.

with the none network, it runs in isolation to the external network. It cannot be accessed.

By default, docker only creates one internal bridge network. We can create our own internal user defined network and have our containers run on that network.

We can do this by running the docker network create command

All containers in a docker host can resolve each other with their names.

Docker has an in-built DNS server that enables containers resolve each other according to their names. This DNS server always runs as 127.0.0.11

Docker uses network namespaces that create a separate namespace for each container. It then uses virtual ethernet pairs to connect containers together.

When you install docker on a system, it creates a /var/lib/docker folder. Under this folder, we have multiple folders, aufs, containers, volumes, images etc

Once a build is complete, you cannot modify the contents of a dockerfile image layers. You can only modify it by rebuilding the image

After the image is done building, docker is going to create a container layer on top of the image layer, this container layer is is only valid for the duration of the container.
It contains any files generated by the container and can be modified. When the container is destroyed, the container layer is destroyed but the image layer still remains and can be
used to generate new containers.

Say, if I want to modify a file, but technically the file is in the image layer, and we know that we cannot edit files in the image layer directly. So how does it work, 
Docker has a Copy on Write mechanism in which anytime I modify a file, a copy of that file is placed in the container layer

If we want to persist the data created in the container layer, we can do so by creating a volume

We can create a volume by making use of the docker volume create command. I can then link the volumes folder on my system to the container so that even if the container is
destroyed, the data is still persisted

If we dont specify a full path and simpley specify a folder name, docker is going to mount the volume of the container inside of that folder. But what if we want to use a folder
other than the ones in /var/lib/docker, to do that, we would specify the full path to the folder.

Volume Mounting mounts the volume to the volumes folder in /var/lib/docker while bind mounting mounts the volume to any location on the docker host.

--mount